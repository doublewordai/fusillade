{
  "db_name": "PostgreSQL",
  "query": "\n            WITH at_risk_requests AS (\n                -- Find requests that need escalation\n                SELECT\n                    r.id as original_request_id,\n                    r.batch_id,\n                    r.retry_attempt,\n                    t.file_id,\n                    t.custom_id,\n                    t.endpoint,\n                    t.method,\n                    t.path,\n                    t.body,\n                    t.model as original_model,\n                    t.api_key as original_api_key,\n                    b.created_by as batch_created_by\n                FROM requests r\n                JOIN request_templates t ON r.template_id = t.id\n                JOIN batches b ON r.batch_id = b.id\n                WHERE t.model = $1\n                  AND r.is_escalated = false\n                  AND r.state = ANY($2)\n                  AND b.expires_at IS NOT NULL\n                  AND b.completed_at IS NULL\n                  AND b.cancelled_at IS NULL\n                  AND b.cancelling_at IS NULL\n                  AND (b.expires_at - NOW()) <= make_interval(secs => $3::float8)\n                  -- Only create escalation if one doesn't already exist\n                  AND NOT EXISTS (\n                      SELECT 1 FROM requests esc\n                      WHERE esc.escalated_from_request_id = r.id\n                  )\n            ),\n            escalation_file AS (\n                -- Create a virtual file to hold escalation templates (not the batch input file)\n                -- This prevents escalation templates from being picked up when creating requests from the batch\n                INSERT INTO files (name, purpose, size_bytes, size_finalized, uploaded_by)\n                SELECT\n                    'escalation-templates-' || gen_random_uuid()::text || '.jsonl',\n                    'escalation_templates',\n                    0,\n                    true,\n                    arr.batch_created_by\n                FROM at_risk_requests arr\n                LIMIT 1\n                RETURNING id\n            ),\n            new_templates AS (\n                -- Create new templates with escalated model and API key in the escalation file\n                INSERT INTO request_templates (file_id, custom_id, endpoint, method, path, body, model, api_key)\n                SELECT\n                    (SELECT id FROM escalation_file),  -- Use the escalation file, NOT the original file\n                    arr.custom_id,\n                    arr.endpoint,\n                    arr.method,\n                    arr.path,\n                    -- Update the model field in the body JSON to match the escalated model\n                    jsonb_set(arr.body::jsonb, '{model}', to_jsonb(COALESCE($4, arr.original_model)))::text,\n                    COALESCE($4, arr.original_model),  -- Use escalated model if provided, else original\n                    COALESCE($5, arr.original_api_key) -- Use escalated API key if provided, else original\n                FROM at_risk_requests arr\n                RETURNING id, (SELECT id FROM escalation_file) as file_id, custom_id, model, api_key\n            )\n            INSERT INTO requests (\n                id, batch_id, template_id, state, custom_id, retry_attempt, model,\n                escalated_from_request_id, is_escalated, superseded_at, superseded_by_request_id\n            )\n            SELECT\n                gen_random_uuid(),\n                arr.batch_id,\n                nt.id,           -- Point to the new template\n                'pending',\n                arr.custom_id,\n                arr.retry_attempt,\n                nt.model,        -- Denormalized model from the new template\n                arr.original_request_id,  -- Link back to original request\n                true,            -- is_escalated = true\n                NULL,\n                NULL\n            FROM at_risk_requests arr\n            JOIN new_templates nt ON arr.custom_id = nt.custom_id\n            ",
  "describe": {
    "columns": [],
    "parameters": {
      "Left": [
        "Text",
        "TextArray",
        "Float8",
        "Text",
        "Text"
      ]
    },
    "nullable": []
  },
  "hash": "c00cf46a212171c8eec370426231758dd829d4c3008bdd4016a0f6175af452f1"
}
